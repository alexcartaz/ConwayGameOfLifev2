{"ast":null,"code":"/*\n***************  Life game code  *************\n */\nfunction generateIndex(row, column) {\n  return row * 50 + column;\n}\n\nfunction calcIndiciesOfNeighbors(currentRow, currentColumn, row_above, row_below, left_column, right_column) {\n  let indices = [];\n  indices.push(generateIndex(row_above, left_column));\n  indices.push(generateIndex(row_above, currentColumn));\n  indices.push(generateIndex(row_above, right_column));\n  indices.push(generateIndex(currentRow, right_column));\n  indices.push(generateIndex(row_below, right_column));\n  indices.push(generateIndex(row_below, currentColumn));\n  indices.push(generateIndex(row_below, left_column));\n  indices.push(generateIndex(currentRow, left_column));\n  return indices;\n}\n\nfunction determineNumberOfAliveNeighbors(board, index) {\n  //default 2500 (50x50)\n  //this approach should work for any board of equal height/width\n  let len = board.length;\n  let numRows = Math.sqrt(len);\n  let currentRow = Math.floor(index / numRows); //btw 1-50\n\n  let currentColumn = index % numRows;\n  let row_above = 0;\n  let row_below = 0;\n  let left_column = 0;\n  let right_column = 0;\n\n  if (currentRow === 0) {\n    row_above = 49;\n  } else {\n    row_above = currentRow - 1;\n  }\n\n  if (currentRow === 49) {\n    row_below = 0;\n  } else {\n    row_below = currentRow + 1;\n  }\n\n  if (currentColumn === 49) {\n    right_column = 0;\n  } else {\n    right_column = currentColumn + 1;\n  }\n\n  if (currentColumn === 0) {\n    left_column = 49;\n  } else {\n    left_column = currentColumn - 1;\n  }\n\n  let indicesOfNeighbors = calcIndiciesOfNeighbors(currentRow, currentColumn, row_above, row_below, left_column, right_column);\n  let numNeighbors = 0;\n\n  for (let i = 0; i < 9; i++) {\n    if (board[indicesOfNeighbors[i]]) {\n      numNeighbors++;\n    }\n  }\n\n  return numNeighbors;\n}\n/*\n Rules:\n   Any live cell with fewer than two live neighbours dies, as if by underpopulation.\n   Any live cell with two or three live neighbours lives on to the next generation.\n   Any live cell with more than three live neighbours dies, as if by overpopulation.\n   Any dead cell with three live neighbours becomes a live cell, as if by reproduction.\n*/\n\n\nexport function iterateGeneration(board) {\n  let newBoard = [];\n  let didChange = false;\n\n  for (let c = 0; c < 2500; c++) {\n    let numNeighbors = determineNumberOfAliveNeighbors(board, c);\n\n    if (board[c] && (numNeighbors === 2 || numNeighbors === 3)) {\n      newBoard[c] = true;\n    } else if (!board[c] && numNeighbors === 3) {\n      newBoard[c] = true;\n    } else {\n      newBoard[c] = false;\n    }\n\n    if (!didChange) {\n      if (newBoard[c] !== board[c]) {\n        didChange = true;\n      }\n    }\n  }\n\n  return {\n    newBoard,\n    didChange\n  };\n}\nexport function initBoard() {\n  let board = [];\n  let randomSeed = 0; //this config makes every 1 in 10 random squares in 100x100\n\n  for (let c = 0; c < 2500; c++) {\n    randomSeed = Math.floor(Math.random() * 11);\n\n    if (randomSeed === 0) {\n      board[c] = true;\n    } else {\n      board[c] = false;\n    }\n  }\n\n  return board;\n}\nexport function clearBoard() {\n  let clearBoard = [];\n\n  for (let c = 0; c < 2500; c++) {\n    clearBoard[c] = false;\n  }\n\n  return clearBoard;\n}\n/*\n***********************************************\n */","map":{"version":3,"sources":["/Users/alex/Lambda/Conways-Life/life/src/lifeFunctions/index.js"],"names":["generateIndex","row","column","calcIndiciesOfNeighbors","currentRow","currentColumn","row_above","row_below","left_column","right_column","indices","push","determineNumberOfAliveNeighbors","board","index","len","length","numRows","Math","sqrt","floor","indicesOfNeighbors","numNeighbors","i","iterateGeneration","newBoard","didChange","c","initBoard","randomSeed","random","clearBoard"],"mappings":"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","sourcesContent":["/*\n***************  Life game code  *************\n */\nfunction generateIndex(row, column){\n  return row*50+column\n}\n\nfunction calcIndiciesOfNeighbors(currentRow, currentColumn, row_above, row_below, left_column, right_column){\n  let indices = []\n  indices.push(generateIndex(row_above,left_column))\n  indices.push(generateIndex(row_above,currentColumn))\n  indices.push(generateIndex(row_above,right_column))\n  indices.push(generateIndex(currentRow,right_column))\n  indices.push(generateIndex(row_below,right_column))\n  indices.push(generateIndex(row_below,currentColumn))\n  indices.push(generateIndex(row_below,left_column))\n  indices.push(generateIndex(currentRow,left_column))\n  return indices\n}\n\nfunction determineNumberOfAliveNeighbors(board, index){\n  //default 2500 (50x50)\n  //this approach should work for any board of equal height/width\n  let len = board.length\n  let numRows = Math.sqrt(len)\n  let currentRow = Math.floor(index / numRows) //btw 1-50\n  let currentColumn = (index % numRows)\n  let row_above = 0\n  let row_below = 0\n  let left_column = 0\n  let right_column = 0\n\n  if (currentRow === 0) {\n    row_above = 49\n  } else {\n    row_above = currentRow - 1\n  }\n\n  if (currentRow === 49) {\n    row_below = 0\n  } else {\n    row_below = currentRow + 1\n  }\n\n  if (currentColumn === 49) {\n    right_column = 0\n  } else {\n    right_column = currentColumn + 1\n  }\n\n  if (currentColumn === 0) {\n    left_column = 49\n  } else {\n    left_column = currentColumn - 1\n  }\n\n  let indicesOfNeighbors = calcIndiciesOfNeighbors(currentRow, currentColumn, row_above, row_below, left_column, right_column)\n  let numNeighbors = 0\n\n  for (let i = 0; i < 9; i++){\n    if (board[indicesOfNeighbors[i]]){\n      numNeighbors++;\n    }\n  }\n\n  return numNeighbors\n}\n\n /*\n  Rules:\n    Any live cell with fewer than two live neighbours dies, as if by underpopulation.\n    Any live cell with two or three live neighbours lives on to the next generation.\n    Any live cell with more than three live neighbours dies, as if by overpopulation.\n    Any dead cell with three live neighbours becomes a live cell, as if by reproduction.\n*/\n\nexport function iterateGeneration(board){\n  let newBoard = []\n  let didChange = false\n  for (let c = 0; c < 2500; c++){\n    let numNeighbors = determineNumberOfAliveNeighbors(board, c)\n    \n    if (board[c] && (numNeighbors===2 || numNeighbors===3)){\n      newBoard[c] = true\n    }else if(!board[c] && numNeighbors===3){\n      newBoard[c] = true\n    }else{\n      newBoard[c] = false\n    }\n    if(!didChange){\n      if(newBoard[c] !== board[c]){\n        didChange = true\n      }\n    }\n  }\n  return { newBoard , didChange }\n}\n\nexport function initBoard(){\n  let board = []\n  let randomSeed = 0\n  //this config makes every 1 in 10 random squares in 100x100\n  for (let c = 0; c < 2500; c++){\n    randomSeed = Math.floor(Math.random() * 11);\n    if (randomSeed === 0) {\n      board[c] = true\n    }else{\n      board[c] = false\n    }\n  }\n  return board\n}\n\nexport function clearBoard(){\n  let clearBoard = []\n  for (let c = 0; c < 2500; c++){\n    clearBoard[c] = false\n  }\n  return clearBoard\n}\n/*\n***********************************************\n */"]},"metadata":{},"sourceType":"module"}